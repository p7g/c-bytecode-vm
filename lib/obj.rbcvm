import "result.rbcvm";

export let E_NO_SUCH_METHOD = -1;

struct Class { super, methods }
struct Object { class, dict }

export function class(super, methods) {
  return Class{super=super, methods=methods};
}

export function new(class, args) {
  let obj = Object{class=class, dict=HashMap.new()};
  send(obj, "init", args);
  return obj;
}

export function getclass(obj) {
  return obj:class;
}

export function getsuper(cls) {
  return cls:super;
}

function resolve_method(cls, name) {
  let meth = null;

  while (null == (meth = HashMap.get(cls:methods, name))
    && null != (cls = cls:super)) {}
  return meth;
}

export function _send(cls, obj, msg, args) {
  let meth = resolve_method(cls, msg);
  if (meth == null) {
    meth = resolve_method(cls, "method_missing");
    if (meth == null) {
        return result.error(E_NO_SUCH_METHOD, msg);
    }
    let args_len = Array.length(args);
    let new_args = Array.new(args_len + 2);
    new_args[0] = obj;
    new_args[1] = msg;
    Array.foreach(args, function(v, i) {
      new_args[i + 1] = v;
    });
    args = new_args;
  } else {
    let args_len = Array.length(args);
    let new_args = Array.new(args_len + 1);
    new_args[0] = obj;
    Array.foreach(args, function(v, i) {
      new_args[i + 1] = v;
    });
    args = new_args;
  }
  return apply(meth, args);
}

export function send(obj, msg, args) {
  return _send(obj:class, obj, msg, args);
}

export function super(obj, msg, args) {
  return _send(obj:class:super, obj, msg, args);
}

export function getattr(obj, name) {
  return HashMap.get(obj:dict, name);
}

export function setattr(obj, name, value) {
  HashMap.set(obj:dict, name, value);
}
