module HashMap;

import "array.rbcvm";
import "arraylist.rbcvm";
import "assoclist.rbcvm";
import "hash.rbcvm";
import "iter.rbcvm";
import "string.rbcvm";

let INITIAL_CAPACITY = toint(2 ** 3);
let LOAD_FACTOR = 0.7;

# hashmap

struct HashMap {
  cap, load, hash_fn, buckets
}

# members

function hash_string(str) {
  return Hash.fnv1a(string_bytes(str));
}

let default_hash = hash_string;

function do_hash(self, key) {
  return self:hash_fn(key) & self:cap - 1;
}

function grow(self) {
  let cap = self:cap = self:cap * 2;

  let old_buckets = self:buckets;
  self:buckets = Array.new(cap);
  self:load = 0;

  Array.foreach(old_buckets, function(bucket) {
    if (!bucket) {
      return;
    }
    Array.foreach(AssocList.entries(bucket), function(entry) {
      set(self, entry[0], entry[1]);
    });
  });
}

# public

export function with_capacity(capacity) {
  return HashMap{
    cap=capacity,
    load=0,
    hash_fn=default_hash,
    buckets=Array.new(capacity),
  };
}

export function new() {
  return with_capacity(INITIAL_CAPACITY);
}

export function set_hash_function(self, func) {
  self:hash_fn = func;
}

export function with_hash_function(hash_function) {
  let m = new();
  set_hash_function(m, hash_function);
  return m;
}

export function get(self, key) {
  let hashed = do_hash(self, key);
  let bucket = self:buckets[hashed];

  if (bucket == null) {
    return null;
  }

  return AssocList.get(bucket, key);
}

export function set(self, key, value) {
  let hashed = do_hash(self, key);
  let bucket = self:buckets[hashed];

  if (bucket == null) {
    bucket = AssocList.new();
    self:load = self:load + 1;
    self:buckets[hashed] = bucket;
  }

  AssocList.set(bucket, key, value);

  if (self:load / self:cap > LOAD_FACTOR) {
    grow(self);
  }
}

export function delete(self, key) {
  let hashed = do_hash(self, key);
  let bucket = self:buckets[hashed];
  if (!bucket) {
    return false;
  }

  if (AssocList.delete(bucket, key)) {
    if (AssocList.is_empty(bucket)) {
      self:buckets[hashed] = null;
      self:load = self:load - 1;
    }
    return true;
  }
  return false;
}

export function has(self, key) {
  let hashed = do_hash(self, key);
  let bucket = self:buckets[hashed];
  if (!bucket) {
    return false;
  }

  return AssocList.has(bucket, key);
}

export function entries(self) {
  let len = Array.length(self:buckets);
  let i = 0;
  let j = 0;
  let bucket = null;

  return function next() {
    if (i >= len) {
      return null;
    }
    if (bucket && j < ArrayList.length(bucket)) {
      let entry = ArrayList.get(bucket, j);
      j = j + 1;
      return entry;
    } else if (bucket) {
      i = i + 1;
    }
    for (; i < len && !(bucket = self:buckets[i]); i = i + 1) {}
    j = 0;
    return next();
  };
}

export function keys(self) {
  return Iter.map(entries(self), function (e) { return e[0]; });
}

export function values(self) {
  return Iter.map(entries(self), function (e) { return e[1]; });
}

export function make_with_hash_function(hash, init_fn) {
  let map = new();
  set_hash_function(map, hash);

  init_fn(function(k, v) {
    set(map, k, v);
  });

  return map;
}

export function make(init_fn) {
  return make_with_hash_function(default_hash, init_fn);
}

export function from_entries_with_hash_function(hash, entries) {
  let map = new();
  set_hash_function(map, hash);
  extend(map, entries);
  return map;
}

export function from_entries(entries) {
  return from_entries_with_hash_function(default_hash, entries);
}

export function extend(map, entries) {
  Iter.foreach(entries, function(entry) {
    set(map, entry[0], entry[1]);
  });
}
